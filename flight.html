<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FocusFlight with Earth Texture</title>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Leaflet CSS and JS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    crossorigin=""
  ></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.min.js"></script>

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Libre+Barcode+39+Text&display=swap" rel="stylesheet" />

  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #111827;
      color: #f3f4f6;
      overflow: hidden;
    }
    .screen {
      display: none;
    }
    .screen.active {
      display: flex;
    }
    #globe-container {
      cursor: grab;
      background-color: #111827;
      width: 100%;
      height: 100%;
      max-width: 640px;
      aspect-ratio: 1 / 1;
      margin: auto;
      border-radius: 16px;
      user-select: none;
      touch-action: none;
    }
    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
      height: 100%;
      background-color: #2a2a2a;
      z-index: 10;
    }
    .ui-overlay {
      z-index: 20;
    }
    .leaflet-control-attribution {
      font-size: 10px !important;
      background: rgba(0,0,0,0.6) !important;
      color: #ccc !important;
    }
    .barcode {
      font-family: 'Libre Barcode 39 Text', cursive;
      font-size: 60px;
      color: #e5e7eb;
      text-align: center;
      overflow: hidden;
      white-space: nowrap;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .animate-pulse-slow {
      animation: pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }
    .pulse-marker {
      background-color: #fbbf24;
      border-radius: 50%;
      width: 15px;
      height: 15px;
      border: 2px solid #fff;
      animation: pulse 2s infinite;
    }
    .leaflet-marker-icon.airplane-marker {
      transition: none !important;
      will-change: transform;
    }
  </style>
</head>
<body class="w-screen h-screen flex flex-col items-center justify-center p-4 sm:p-10">
  <div id="globe-container"></div>

  <!-- Setup screen, boarding screen, focus screen, summary screen, logbook screen -->
  <!-- For brevity, include the HTML content for these screens from your existing code -->

  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Your cities array comes here like previous example

    const state = {
      currentScreen: 'setup',
      departureCity: null,
      arrivalCity: null,
      durationMinutes: 60,
      flightLog: JSON.parse(localStorage.getItem('flightLog')) || [],
      timerInterval: null,
      globeInitialized: false,
      flightDistance: 0,
    };

    const container = document.getElementById('globe-container');
    let scene, camera, renderer, controls, earth, starSphere, raycaster, mouse, cityMarkers = new THREE.Group();

    function latLonToVector3(lat, lon, radius) {
      const phi = (90 - lat) * Math.PI / 180;
      const theta = (lon + 180) * Math.PI / 180;
      return new THREE.Vector3(
        -radius * Math.sin(phi) * Math.cos(theta),
        radius * Math.cos(phi),
        radius * Math.sin(phi) * Math.sin(theta)
      );
    }

    async function initGlobe() {
      if(state.globeInitialized) return;

      scene = new THREE.Scene();

      // Camera
      camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
      camera.position.z = 2.5;

      // Renderer
      renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enablePan = false;
      controls.minDistance = 1.5;
      controls.maxDistance = 5;

      // Lighting
      scene.add(new THREE.AmbientLight(0x404040, 2));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(5, 3, 5);
      scene.add(dirLight);

      // Earth texture - replace black globe with photo-realistic Earth map
      const textureLoader = new THREE.TextureLoader();
      const earthTexture = await new Promise(resolve => {
        textureLoader.load('https://www.solarsystemscope.com/textures/download/2k_earth_daymap.jpg', tex => resolve(tex));
      });

      // Earth
      earth = new THREE.Mesh(new THREE.SphereGeometry(1, 64, 64), new THREE.MeshPhongMaterial({map: earthTexture, shininess: 5}));
      scene.add(earth);

      // Starfield background (large sphere inverted)
      const starTexture = await new Promise(resolve => {
        textureLoader.load('https://cdn.polyhaven.com/asset_img/thumbs/starry_night.jpg?width=1920', tex => resolve(tex));
      });

      const starGeometry = new THREE.SphereGeometry(80, 64, 64);
      const starMaterial = new THREE.MeshBasicMaterial({map: starTexture, side: THREE.BackSide});
      starSphere = new THREE.Mesh(starGeometry, starMaterial);
      scene.add(starSphere);

      // Add city markers (same as before)
      const markerMaterial = new THREE.MeshBasicMaterial({color: 0xFBBF24});
      cities.forEach(city => {
        const marker = new THREE.Mesh(new THREE.SphereGeometry(0.008, 16, 16), markerMaterial.clone());
        const pos = latLonToVector3(city.lat, city.lon, 1);
        marker.position.set(pos.x, pos.y, pos.z);
        marker.userData.city = city;
        cityMarkers.add(marker);
      });
      earth.add(cityMarkers);

      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });

      container.addEventListener('click', onGlobeClick);
      animate();

      state.globeInitialized = true;
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    function onGlobeClick(event) {
      event.preventDefault();
      const bounds = event.currentTarget.getBoundingClientRect();
      mouse.x = ((event.clientX - bounds.left) / bounds.width) * 2 - 1;
      mouse.y = -((event.clientY - bounds.top) / bounds.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(cityMarkers.children);
      if(intersects.length > 0) {
        handleCityClick(intersects[0].object.userData.city);
      }
    }

    function handleCityClick(city) {
      if(!state.departureCity){
        state.departureCity = city;
        highlightMarker(city, true);
      } else if(!state.arrivalCity && city.id !== state.departureCity.id) {
        state.arrivalCity = city;
        highlightMarker(city, true);
        // draw path on globe or elsewhere
      } else {
        highlightMarker(state.departureCity, false);
        if(state.arrivalCity) highlightMarker(state.arrivalCity, false);
        state.departureCity = city;
        state.arrivalCity = null;
        highlightMarker(city, true);
      }
      updateUI();
    }

    function highlightMarker(city, selected) {
      const marker = cityMarkers.children.find(m => m.userData.city.id === city.id);
      if(marker){
        marker.material.color.set(selected ? 0xffffff : 0xFBBF24);
        marker.scale.set(selected ? 1.5 : 1, selected ? 1.5 : 1, selected ? 1.5 : 1);
      }
    }

    // Add other UI and Flight logic here (Leaflet map flight, airplane, logs...)

    // Initialization
    navigateTo('setup');

  </script>
</body>
</html>
